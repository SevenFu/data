#   AUTHOR: Matthew S. Atwood <matthew.s.atwood@intel.com>
import os
import csv
import re
import matplotlib.pyplot as pyplot

class StatsCollection:
    def __init__(self):
        self.collection = []
        self.ticks = []

    def getCollection(self):
        return self.collection

    def getTicks(self):
        return self.ticks

    def getStats(self):
        return getStatsFromList(self.collection)

    def generateCSVRows(self):
        if self.ticks == [] or self.collection == []:
            return []
        else:
            return [[self.ticks[i], self.collection[i]]
                    for i in range(0, len(self.ticks))]

    def plot(self, labelText):
        pyplot.plot(self.ticks, self.collection, label=labelText)


class ExtechFile:
# DESCRIPTION
#   Class used for pulling out meaningful performance statistics generated by
#   the Extech Power Analyzer 308083. Currently only Watts is tracked. If
#   passed an file that does not exist, generates an empty object. Will error
#   if invalid file type, or if file cannot be opened for read.
    def __init__(self, paFile):
        self.watts = StatsCollection()
        self.label = os.path.split(paFile)[1][:-3]

        if os.path.exists(paFile):
            try:
                fp = open(paFile, 'r')
            except IOError:
                raise IOError('Unable to open {0} for reading'.format(pa_file))
            else:
                reader = csv.reader(fp)
                pa_lines = [row for row in reader]
                fp.close()
                self.watts.collection = [float(line[1]) for line in pa_lines]
                self.watts.ticks = [float(line[0]) for line in pa_lines]

        else:
            pass

    def generateCSVRows(self):
        header = [['Time (seconds)', 'Watts']]
        return header + self.watts.generateCSVRows()

    def plot(self, total=4, col=1, row=1, labelText=''):
        if labelText != '':
            labelText = '-{0}'.format(labelText)
        start = (total * 100) + (10 * col) + row
        pyplot.subplot(start)
        pyplot.xlabel('Time (seconds)')
        pyplot.ylabel('Watts')
        self.watts.plot('watts-{0}{1}'.format(self.label, labelText))
        pyplot.legend(loc=3)

    def getStats(self):
        return self.watts.getStats()

class VMStatFile:
# DESCRIPTION
#   Class used for pulling meaninful performance statistics generated by
#   VMSTAT application. Currently memory available, interrupts, context
#   switches, system cpu usage and user cpu usage are tracked. If passed a file
#   that does not exist, generates an empty object. Will error if passed an
#   invalid file type or if file cannot be opened for read.
    def __init__(self, vmsFile):
        self.label = os.path.split(vmsFile)[1][:-4]
        self.mem = StatsCollection()
        self.irq = StatsCollection()
        self.cs = StatsCollection()
        self.sys = StatsCollection()
        self.us = StatsCollection()

        if(os.path.exists(vmsFile)):
            try:
                fp = open(vmsFile, 'r')
            except IOError:
                raise IOError('Unable to open {0} for reading'.format(vmsFile))
            else:
                vmsLines = [line for line in fp.readlines() if 'r' not in line]
                fp.close()

                self.mem.collection = [int(entry.split()[3])
                                        for entry in vmsLines]
                self.irq.collection = [int(entry.split()[10])
                                        for entry in vmsLines]
                self.cs.collection = [int(entry.split()[11])
                                        for entry in vmsLines]
                self.sys.collection = [int(entry.split()[12])
                                        for entry in vmsLines]
                self.us.collection = [int(entry.split()[13])
                                        for entry in vmsLines]

                self.mem.ticks = range(0, len(vmsLines))
                self.irq.ticks = range(0, len(vmsLines))
                self.cs.ticks = range(0, len(vmsLines))
                self.sys.ticks = range(0, len(vmsLines))
                self.us.ticks = range(0, len(vmsLines))
        else:
            pass

    def generateCSVRows(self):
        header = [['Ticks',
                   'Memory Available (bytes)',
                   'Interrupts',
                   'Context Switches',
                   'System CPU Usage (%)',
                   'User CPU Usage (%)']]
        csvrows = [[self.mem.ticks[i], self.mem.collection[i],
                    self.irq.collection[i], self.cs.collection[i],
                    self.sys.collection[i], self.us.collection[i]]
                    for i in range(0, len(self.mem.ticks))]
        return header + csvrows

    def plot(self, total=4, col=1, row=1, labelText=''):
        if labelText != '':
            labelText = '-{0}'.format(labelText)
        start = (total * 100) + (col * 10) + row
        pyplot.subplot(start)
        pyplot.xlabel('Time (vms ticks)')
        pyplot.ylabel('Memory Available (bytes)')
        self.mem.plot('mem-{0}{1}'.format(self.label, labelText))
        pyplot.legend(loc=3)

        pyplot.subplot(start + 1)
        pyplot.xlabel('Time (vms ticks)')
        pyplot.ylabel('events')
        self.irq.plot('irq-{0}{1}'.format(self.label, labelText))
        self.cs.plot('cs-{0}{1}'.format(self.label, labelText))
        pyplot.legend(loc=3)

        pyplot.subplot(start + 2)
        pyplot.xlabel('Time (vms ticks)')
        pyplot.ylabel('CPU Consumption (%)')
        self.sys.plot('sys-{0}{1}'.format(self.label, labelText))
        self.us.plot('us-{0}{1}'.format(self.label, labelText))
        pyplot.legend(loc=3)

    def getStats(self):
        return dict([('mem', self.mem.getStats()),
                    ('irq', self.irq.getStats()),
                    ('cs', self.cs.getStats()),
                    ('sys', self.sys.getStats()),
                    ('us', self.us.getStats())])


class ResultsFile:
    def __init__(self, resultsName):
        self.label = os.path.split(resultsName)[1]
        self.result = {}
        self.primaryResult = None
        if os.path.exists(resultsName):
            try:
                fp = open(resultsName, 'r')
            except IOError:
                raise IOError('Unable to open {0} for reading'.format(resultsFile))
            else:
                resultsLines = fp.readlines()
                for line in resultsLines:
                    if re.findall(r': \d+\.\d+', line): #speedometer, smoothness, page_cycler
                        self.result[str(line.split(': ')[0])] = float(re.findall(r'\d+\.\d+', line)[0])
                        if self.primaryResult is None:
                            self.primaryResult = self.result[str(line.split(': ')[0])]
                    elif re.findall(r'\w+, +\d+?\.?\d*,?', line): #others
                        self.result[str(line.split(',')[0])] = float(line.split(',')[1])
                        if self.primaryResult is None:
                            self.primaryResult = line.split(',')[1]
        else:
            pass

    def generateCSVRows(self):
        return [['metric, score,']] + [["{0}, {1},".format(key, self.result[key])]
                for key in self.result.keys()]

class PayloadPickle:
    def __init__(self, fileName):
        self.label = os.path.split(fileName)[1]
        self.result = None
        self.profiles = {}

        self.result = ResultsFile('{0}.res'.format(fileName))
        self.profiles['extech'] = ExtechFile('{0}.ex'.format(fileName))
        self.profiles['vmstat'] = VMStatFile('{0}.vms'.format(fileName))

def getStatsFromList(stats):
# DESCRIPTION:
#   Quick helper function used by StatsCollection object. Returns dict with
#   min, mean, max.
    if len(stats) == 0:
        return dict([('min', -1), ('mean', -1), ('max', -1)])

    min = stats[0]
    max = stats[0]
    mean = 0

    for stat in stats:
        if stat < min:
            min = stat
        if stat > max:
            max = stat
        mean += stat
    mean /= len(stats)

    return dict([('min', min), ('mean', mean), ('max', max)])
